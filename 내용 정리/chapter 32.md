# 32장 TDD 마스터하기

## 단계가 얼마나 커야 하는가?

- 사실 여기에는 두 가지 질문이 숨어 있다.

  - 각 테스트가 다뤄야 할 범위는 얼마나 넓은가?

  - 리팩토링을 하면서 얼마나 많은 중간 단계를 거쳐야 하는가?

- 만약 한 줄의 로직을 추가하고 약간의 리팩토링을 할 수 있을 정도 크기의 테스트를 만들 수 있는가 하면, 수백 줄의 로직과 수시간 분량의 리팩토링을 할 만큼의 크기를 갖는 테스트를 만들 수도 있다.
  - 당신은 둘 다 할 수 있어야 한다.

- 시간이 지남에 따라 테스트 주도 개발자(Test-Driven Developer)의 경향은 단계가 점점 작아지는 방향으로 나타난다.

- 리팩토링 초기에는 아주 작은 단계로 시작해야 한다.
  - 매우 작은 단계로 수작업 리팩토링을 20번 하고 나면, 몇 단계 건너 뛰는 실험을 해보라

## 테스트할 필요가 없는 것은 무엇인가?

- 애플리케이션 개발에 있어서 두려움이 지루함으로 변할때까지 테스트를 만드는 것이다.

- 그러나 결국 스스로 대답을 찾아야만 한다. 다음 것들을 테스트해야 한다.

  - 조건문

  - 반복문

  - 연산자

  - 다형성

- 당신이 작성하는 것들에 대해서만 테스트하라. 불신할 이유가 없다면 다른 사람이 만든 코드를 테스트하지 마라.

## 좋은 테스트를 갖췄는지의 여부를 어떻게 알 수 있는가?

다음은 설계 문제가 있음을 알려주는 테스트의 속성이다.

- **긴 셋업 코드 :** 하나의 단순한 단언을 수행하기 위해 수백 줄의 객체 생성 코드가 필요하다면 객체가 너무 크다는 뜻이므로 나뉠 필요가 있다.
- **셋업 중복** : 공통의 셋업 코드를 넣어 둘 공통의 장소를 찾기 힘들다면, 서로 밀접하게 엉킨 객체들이 너무 많다는 뜻이다.
- **실행 시간이 오래 걸리는 테스트** : 실행하는 데 오래 걸리면 테스트를 자주 실행하지 않게 되고, 한동안 실행이 안 된 채로 남게 되는 경우가 종종 있고, 이렇게 되면 테스트가 아예 동작하지 않을 수도 있다. 더 나쁜 점은, 애플리케이션의 작은 부분만 따로 테스트하기가 힘들다는 것을 의미한다.
- **깨지기 쉬운 테스트** : 예상치 못하게 실패하는 테스트가 있다면 이는 애플리케이션의 특정 부분이 다른 부분에 이상한 방법으로 영향을 끼친다는 뜻이다. 연결을 끊거나 두 부분을 합하는 것을 통해 멀리 떨어진 것의 영향력이 없어지도록 설계해야 한다.

## TDD로 프레임워크를 만들려면 어떻게 해야 하나?

- TDD를 수행함에 따라 개방-폐쇄의 원칙은 서서히 지켜져 가는데, 실제로 발생하는 변주들에 대해서는 특히 더 그렇다.
- 테스트 주도 개발은 비록 발생하지 않은 변주 종류는 잘 표현하지 못할지라도, 발생하는 변주 종류는 그것들을 잘 표현하는 프레임워크를 만들게 해 준다.

- 그래서 3년 후에 일반적이지 않은 변화가 발생하면 어떻게 될까? 그 변화를 수용하기 위해 정확히 필요한 지점에서 설계가 급격한 진화를 거치게 된다.
- 이는 개방-폐쇄 원칙을 잠시 위배하게 되지만, 이에 따른 비용은 크지 않다.
- 왜냐하면 스스로 뭔가를 잘못하지 않았다는 확신을 줄 수 있는 많은 테스트들이 존재하기 때문이다.



## 피드백이 얼마나 필요한가?

테스트를 얼마나 작성해야 할까?

------

**작은 예제를 직접 스스로 풀어보라.**

**삼각형의 각 변의 길이를 나타내는 세 개의 정수를 받아서 다음 값을 반환하는 문제다.**

- **정삼각형이면 1을 반환**
- **이등변삼각형이면 2를 반환**
- **부등변삼각형이면 3을 반환**
- **삼각형이 될 수 없다면 예외를 던진다.**

------

필자는 이 문제를 풀기위해 6개의 테스트를 작성했고, 누군가는 같은 문제를 위해 65개의 테스트를 작성한다. 당신은 자신의 경험과 숙고를 통해, 얼마나 많은 테스트를 작성할지 결정해야 할 것이다.

- TDD의 테스트에 대한 관점은 실용적이다.
- 만약 어떤 구현에 대한 지식이 신뢰할 만 하다면 그에 대한 테스트는 작성하지 않을 것이다.

## 테스트를 지워야 할 때는 언제인가?

테스트가 많으면 좋기야 하지만, 서로 겹치는 두 개의 테스트가 있어도 이들을 남겨두어야 할까? 답은 두 가지 기준에 의해 결정된다.

- 첫째 기준은 자신감이다. 테스트를 삭제할 경우 자신감이 줄어들 것 같으면 절대 테스트를 지우지 말아야 한다.
- 둘째 기준은 커뮤니케이션이다. 두 개의 테스트가 코드의 동일한 부분을 실행하더라도, 이 둘이 서로 다른 시나리오를 말한다면 그대로 남겨두어야 한다.

자신감이나 커뮤니케이션 면에서 별 부가적인 이득이 없는 중복 테스트가 존재한다면, 덜 유용한 것을 삭제하라.

## 프로그래밍 언어나 환경이 TDD에 어떤 영향을 주는가?

TDD 주기(테스트/컴파일/실행/리팩토링)를 수행하기가 힘든 언어나 환경에서 작업하게 되면 단계가 커지는 경향이 있다.

- 각 테스트가 더 많은 부분을 포함하게 만든다.
- 중간 단계를 덜 거치고 리팩토링을 한다.



## 거대한 시스템을 개발할 때에도 TDD를 할 수 있는가?

- 필자가 관여한 시스템 중 완전히 TDD로 개발된 가장 큰 시스템은 LifeWare에서 개발한 것이다.
  - 4년간 40인/년이 투입
- 시스템에 있는 기능의 양은 TDD의 효율에 영향을 미치지 않는 것 같다.

## 애플리케이션 수준의 테스트로도 개발을 주도할 수 있는가?

- 작은 규모의 테스트로 개발을 주도하는 것의 문제는 실제로 사용자가 원하지 않는데 그들이 원할 거라 생각하고 구현할 수도 있는 위험을 끌고 간다는 점에 있다.
- 애플리케이션 수준에서 테스트를 작성한다면 프로그래머에게 약간의 도움을 받아서 사용자가 원하는 바를 테스트로 작성할 수 있을 것이다.
  - 하지만 여기에는 기술적인 문제가 있다. 바로 고정물을 만드는 것이다.
  - 아직 만들지 않은 기능에 대한 테스트를 어떻게 작성하고 실행할 것인가?

- 애플리케이션 테스트 주도 개발(ATDD, Application Test-Driven Development)에는 사회적인 문제가 존재한다.

  - 사용자에게 테스트를 작성시키는 책임을 부여하는 것이다.

- 또 다른 문제는 테스트와 피드백 사이의 길이다. 만약 고객이 테스트를 작성하고 통과하기까지 열흘이 걸린다면, 거의 열흘동안 빨간 막대만 보게 될 것이다. 

- 필자는 앞으로도 프로그래머 수준의 TDD를 원할 것 같다.

  - 즉시 초록 막대를 볼 수 있고

  - 내부 설계를 단순화할 수 있길 원한다.

## 프로젝트 중반에 TDD를 도입하려면 어떻게 해야 할까?

- 테스트를 염두에 두지 않고 만든 코드는 테스트하기 쉽지 않다
- "고치면 되지 않은가?"라는 질문을 할 수 있겠지만, 리팩토링 과정에서 에러가 발생할 수도 있는데 아직 테스트가 없기 때문에 에러가 생겼다는 점을 알아내기가 매우 힘들다.
- 따라서 먼저 해야 할 일은 **변경의 범위를 제한하는 것**이다. 지금 당장 변할 필요가 없는 부분을 봤다면, 그냥 그대로 놔둘 것이다.
- 그 다음으로는 **테스트와 리팩토링 사이에 존재하는 교착 상태(deadlock)를 풀어주는 것**이다. 테스트가 아닌 다른 방법으로도 피드백을 얻을 수 있는데, 아주 조심스럽게 작업을 하거나 파트너와 함께 작업을 하는 방법 등이 그런 것이다.

## TDD는 누구를 위한 것인가?

- 만약 당신이 어느 정도는 작동하는 코드를 한번에 몰아 입력해 넣는 것에 행복해 하고, 그 결과를 두 번 다시 쳐다보지 않는 것에 행복해 한다면, TDD는 당신을 위한 것이 아니다. 
- TDD는 더 나은 코드를 작성한다면 좀더 성공할 것이라는, 매력적일 정도로 나이브하며 해커적인(geekoid) 가정에 근거한다.
- TDD는 코드에 감정적 애착을 형성하는 해커들에게 좋다.

- 사실 TDD는 오버액션이다. TDD는 현재 업계에서 통용하는 수준보다 훨씬 더 적은 수의 결함과 훨씬 더 깨끗한 설계의 코드를 작성하게 해준다.

- TDD를 사용하지 않으면 엄청난 흥미를 가지고 새 프로젝트를 시작해서는 시간이 지남에 따라 서서히 코드가 썩어가는 걸 보게되면서 하루빨리 이를 버려버리고 새로운 프로젝트가 시작되기를 기다리는걸 심심치 않게 볼 수 있다.
- 그러나 TDD는 시간이 지남에 따라 코드에 대한 자신감을 점점 더 쌓아갈 수 있게 해준다. 테스트가 쌓여감에 따라(그리고 테스팅 기술이 늘어감에 따라) 시스템의 행위에 대한 자신감을 얻게 되고, 설계를 개선해 나감에 따라 점점 더 많은 설계 변경이 가능해진다.

## TDD는 초기 조건에 민감한가?

- 테스트를 특정 순서로 구현하는 것이 다른 순서에 비해 훨씬 빠르고 쉽다는 것이 사실인가?
- 단지 내가 구현 기술이 부족해서는 아닐까? 
- 혹 테스트를 특정 순서로 공략해야 한다는 것을 넌지시 알려주는 무언가가 테스트 속에 있는 건 아닐까?

## TDD와 패턴의 관계는?

- 반복적 행동을 규칙으로 환원함으로써 규칙을 적용하는 것이 기계적이며 단순 암기가 된다는 점이다.
- 처음에는 규칙을 찾아보거나 새로운 규칙을 기록하기 위해 속도가 훨씬 느리지만, 일주일 후에는 속도가 훨씬 빨라진다.
- TDD와 패턴의 또 다른 관계는 패턴 주도 설계(Pattern-Driven Design)에 대한 구현 방법으로써 TDD다.
- 어떤 작업을 수행하기 위해 전략(Strategy) 패턴을 사용하기로 결정했다고 가정해보자.
- 그 다음 리팩토링 단계에서 자연스럽게 전략 패턴이 나타날 수 있도록 하기 위해 의식적으로 두 번째 테스트를 작성해본다. 
- 문제는 설계가 항상 의도하지 않은대로 흘러간다는 것이다. 완벽하게 사리에 맞는 설계 아이디어가 결국은 틀린 것으로 판명난다. 그냥 시스템이 무슨 일을 할지 생각하고 나중에 설계가 알아서 정해지도록 하는 것이 더 낫다.

## 어째서 TDD가 잘 작동하는가?

- TDD는 결함을 빨리 발견해 고칠 수 있게함으로써 비용을 낮출 수 있다. 그러면서 결함 감소에서 오는 이차적인 심리학적, 사회적인 효과가 많다.
  - 결함은 빨리 발견해 고칠수록 비용이 낮아진다.
  - 팀원과의 관계가 더 긍정적으로 변했다.
  - 사람들은 내 소프트웨어로 작업하는 것을 신뢰할 수 있다.
  - 새로 릴리즈한 시스템은 더 이상 새로운 버그의 근원지가 아니다.
- TDD의 또다른 효과는 설계 결정에 대한 피드백 고리를 단축시킨다는 점이다.
  - 설계에 대한 생각과 그 첫 번째 예제 사이의 간격이 피드백 고리이다.

## 이름을 테스트 주도 개발이라고 한 이유는?

- 개발 : 소프트웨어 개발을 어떤 단계(분석 부터 배포에 이르는)에 따라 나누는 과거의 사고방식은 약화됐다. 분석, 논리적 설계, 물리적 설계, 구현, 테스팅, 검토, 통합, 배포를 아우르는 것을 개발이라 한다.
- 주도 : 어떤 이름의 반대는 최소한 모호하게라도 불만족스러워야 한다는 명명 규칙에 따라 '테스트 우선'에서 '테스트 주도'로 바꿈
- 테스트 : 자동화되고 추제적이고 명확한 테스트를 말한다. TDD는 테스트 기술이 아니라 분석 기술이며 설계 기술이다.



## TDD와 익스트림 프로그래밍의 실천법 사이에 어떤 관련이 있는가?

- 짝 프로그래밍 : 짝으로 일하는 것은 TDD를 강화시킴. 그 리듬 때문에 몰입할 수 있으며, 지칠 때 활기를 줌. 작성하게 되는 테스트는 짝 프로그래밍 과정에서 좋은 의사소통 수단이 됨.
- 활기차게 일하기 : 기운이 있을 때 일을 시작해, 지치면 그만할 것을 권유
- 지속적인 통합 : 테스트는 더 자주 통합할 수 있게 해주기 때문에 훌륭한 자원이 됨. 테스트 통과 및 중복을 제거 후에 체크인.
- 단순설계 : 테스트를 통과하기 위해 최소한의 필요한 코딩을 하고 중복을 제거한다면, 자동으로 요구사항에 맞는 설계를 얻음. 
- 리팩토링 : 테스트가 있다면 큰 리팩토링을 수행하더라도 시스템의 행위가 변하지 않았다는 자신감을 얻을수 있음.
- 지속적인 전달 : 고객을 혼란시키지 않으면서도 더 자주 코드를 출시할 수 있음
